import java_cup.runtime.*;
import exceptions.*;
import java.util.ArrayList;
import ast.*;

parser code {:
    public moduleBlock root;

    public moduleBlock getAST() {
        return root;
    }
:}

init with {:
    root = null;
:}

scan with {:
    return getScanner().next_token();
:}

/* types */
terminal INTEGER, BOOLEAN, ARRAY, RECORD;

/* builtin functions */
terminal WRITE, WRITELN, READ;

/* keywords */
terminal OF, VAR, PROCEDURE, BEGIN, END, IF, THEN, ELSE, WHILE, DO, ELSIF, CONST, MODULE, TYPE;

/* operators */
terminal ASSIGN, COMMA, DOT, COLON, SEMICOLON, LPAREN, RPAREN, LBRACKET, RBRACKET, EQUAL, NOT_EQUAL, LESS_EQUAL, LESS, GREATER_EQUAL, GREATER, ADD, MINUS, MUL, DIV, MOD;
terminal AND, OR, NOT;

/* constant */
terminal String IDENTIFIER;
terminal Integer NUMBER;

/* where to start parse */
non terminal program;

non terminal moduleBlock modules;
non terminal declarations declaration;
non terminal procedureDec procedure_declaration;
non terminal procedureHead procedure_head;
non terminal procedureBody procedure_body;
non terminal formalParameters formal_parameters;
non terminal fpSection fp_section;
non terminal typeAST type;
non terminal recordType record_type;
non terminal arrayType array_type;
non terminal fieldList field_list;
non terminal identifierList identifier_list;
non terminal stmts statement_sequence;
non terminal stmt statement;
non terminal assignmentStmt assignment;
non terminal callStmt procedure_call;
non terminal ifStmt if_statement;
non terminal whileStmt while_statement;
non terminal actualParameters actual_parameters;
non terminal expr expression;
non terminal simpleExpr simple_expression;
non terminal termAST term;
non terminal factorAST factor;
non terminal numberAST numbers;
non terminal selectorAST selector;

non terminal stmts modules_tail;
non terminal ArrayList<constDec> const_declaration;
non terminal ArrayList<varDec> var_declaration;
non terminal ArrayList<typeDec> type_declaration;
non terminal ArrayList<procedureDec> procedure_declarations;

non terminal ArrayList<constDec> const_dectail;
non terminal ArrayList<varDec> var_dectail;
non terminal ArrayList<typeDec> type_dectail;

non terminal stmts procedure_body_tail;
non terminal formalParameters procedure_head_tail;
non terminal ArrayList<fpSection> fp_section_tail;

non terminal Boolean var_if;

non terminal ArrayList<fieldList> record_tail;

non terminal ArrayList<String> identifier_list_tail;

non terminal ArrayList<stmt> statement_sequence_tail;

non terminal ifStmt elsif_part;
non terminal stmts else_part;

non terminal actualParameters procedure_call_tail;
non terminal ArrayList<expr> actual_parameters_tail;

non terminal expr expr_tail;
non terminal String tail_op;

non terminal String head_op;
non terminal simpleExpr simple_expression_tail;
non terminal String simple_tail_op;

non terminal termAST term_tail;
non terminal String term_tail_op;

precedence right ASSIGN;
precedence left OR;
precedence left AND;
precedence right NOT;
precedence left EQUAL, NOT_EQUAL, LESS, LESS_EQUAL, GREATER, GREATER_EQUAL;
precedence left ADD, MINUS;
precedence left MUL, DIV, MOD;
precedence left LPAREN;

start with program;

program ::= modules:m 
{: 
    root = m;
    root.convert();
:};

modules ::= MODULE IDENTIFIER:id SEMICOLON declaration:d modules_tail:s END IDENTIFIER:id1 DOT
{:
    if (!id.equals(id1))
        throw new SemanticException("module name mismatch");
    RESULT = new moduleBlock(id, d, s);
:};

modules_tail ::= BEGIN statement_sequence:s 
{: RESULT = s; :}
| {: RESULT = null; :};

declaration ::= const_declaration:c type_declaration:t var_declaration:v procedure_declarations:p
{:
    RESULT = new declarations(c, t, v, p);
:};

const_declaration ::= CONST const_dectail:ct
{: RESULT = ct; :}
| {: RESULT = null; :};
const_dectail ::= IDENTIFIER:id EQUAL expression:e SEMICOLON const_dectail:ct
{:
    if (ct == null)
        RESULT = new ArrayList<>();
    else
        RESULT = ct;
    RESULT.add(new constDec(id, e));
:}
| {: RESULT = null; :};

type_declaration ::= TYPE type_dectail:tt
{: RESULT = tt; :}
| {:RESULT = null; :};
type_dectail ::= IDENTIFIER:id EQUAL type:t SEMICOLON type_dectail:tt
{:
    if (tt == null)
        RESULT = new ArrayList<>();
    else
        RESULT = tt;
    RESULT.add(new typeDec(id, t));
:}
| {: RESULT = null; :};

var_declaration ::= VAR var_dectail:vt
{: RESULT = vt; :}
| {:RESULT = null; :};

var_dectail ::= identifier_list:il COLON type:t SEMICOLON var_dectail:vt
{:
    if (vt == null)
        RESULT = new ArrayList<>();
    else
        RESULT = vt;
    RESULT.add(new varDec(il, t));
:}
| {: RESULT = null; :};

procedure_declarations ::= procedure_declaration:p SEMICOLON procedure_declarations:pd
{:
    if (pd == null)
        RESULT = new ArrayList<>();
    else
        RESULT = pd;
    RESULT.add(p);
:}
| {: RESULT = null; :};

procedure_declaration ::= procedure_head:h SEMICOLON procedure_body:b
{:
    if (!h.name.equals(b.name))
        throw new SemanticException("procedure name mismatch");
    RESULT = new procedureDec(h, b);
:};

procedure_body ::= declaration:d procedure_body_tail:pbd END IDENTIFIER:id
{:
    RESULT = new procedureBody(d, pbd, id);
:};

procedure_body_tail ::= BEGIN statement_sequence:s 
{: RESULT = s; :}
| {: RESULT = null; :};

procedure_head ::= PROCEDURE IDENTIFIER:id procedure_head_tail:fp
{:
    RESULT = new procedureHead(id, fp);
:};

procedure_head_tail ::= formal_parameters:fp
{: RESULT = fp; :}
| {: RESULT = null; :};

formal_parameters ::= LPAREN fp_section:fp fp_section_tail:fpt RPAREN
{:
    if (fpt == null)
        RESULT = new formalParameters();
    else
        RESULT = new formalParameters(fpt);
    RESULT.fpList.add(fp);
:}
| LPAREN RPAREN
{:
    RESULT = new formalParameters();
:};

fp_section_tail ::= SEMICOLON fp_section:fp fp_section_tail:fpt
{:
    if (fpt == null)
        RESULT = new ArrayList<>();
    else
        RESULT = fpt;
    RESULT.add(fp);
:}
| {: RESULT = null; :};


fp_section ::= var_if:isvar identifier_list:il COLON type:t
{:
    RESULT = new fpSection(isvar, il, t);
:};

var_if ::= VAR {: RESULT = true; :}
| {: RESULT = false; :};

type ::= IDENTIFIER:id
{:
    RESULT = new typeAST(id);
:}
| INTEGER {: RESULT = new typeAST("INTEGER"); :}
| BOOLEAN {: RESULT = new typeAST("BOOLEAN"); :}
| array_type:a
{:
    RESULT = new typeAST("array", a);
:}
| record_type:r
{:
    RESULT = new typeAST("record", r);
:};

record_type ::= RECORD field_list:f record_tail:rt END
{:
    if (rt == null)
        RESULT = new recordType();
    else
        RESULT = new recordType(rt);
    RESULT.fieldLists.add(f);
:};

record_tail ::= SEMICOLON field_list:f record_tail:rt
{:
    if (rt == null)
        RESULT = new ArrayList<>();
    else
        RESULT = rt;
    RESULT.add(f);
:}
| {: RESULT = null; :};

field_list ::= identifier_list:il COLON type:t
{:
    RESULT = new fieldList(il, t);
:}
| {: RESULT = null; :};

array_type ::= ARRAY expression:e OF type:t
{:
    RESULT = new arrayType(e, t);
:};

identifier_list ::= IDENTIFIER:id identifier_list_tail:ilt
{:
    if (ilt == null)
        RESULT = new identifierList();
    else
        RESULT = new identifierList(ilt);
    RESULT.identifiers.add(id);
:};

identifier_list_tail ::= COMMA IDENTIFIER:id identifier_list_tail:ilt
{:
    if (ilt == null)
        RESULT = new ArrayList<>();
    else
        RESULT = ilt;
    RESULT.add(id);
:}
| {: RESULT = null; :};

statement_sequence ::= statement:s statement_sequence_tail:sst
{:
    if (sst == null)
        RESULT = new stmts();
    else
        RESULT = new stmts(sst);
    RESULT.statements.add(s);
:};

statement_sequence_tail ::= SEMICOLON statement:s statement_sequence_tail:sst
{:
    if (sst == null)
        RESULT = new ArrayList<>();
    else
        RESULT = sst;
    RESULT.add(s);
:}
| {: RESULT = null; :};

statement ::= assignment:a {: RESULT = new stmt(a); :}
| procedure_call:p {: RESULT = new stmt(p); :}
| if_statement:i {: RESULT = new stmt(i); :}
| while_statement:w {: RESULT = new stmt(w); :};

while_statement ::= WHILE expression:e DO statement_sequence:ss END
{:
    RESULT = new whileStmt(e, ss);
:};

if_statement ::= IF expression:e THEN statement_sequence:ss elsif_part:el else_part:endp END
{:
    RESULT = new ifStmt(e, ss, el.elseIfs, endp);
:};

elsif_part ::= ELSIF expression:e THEN statement_sequence:ss elsif_part:el
{:
    if (el == null) 
        RESULT = new ifStmt();
    else
        RESULT = el;
    RESULT.elseIfs.add(new ifStmt(e, ss, true));
    RESULT.isElseIf = true;
:}
| {: RESULT = null; :};

else_part ::= ELSE statement_sequence:ss
{:
    RESULT = ss;
:}
| {: RESULT = null; :};

procedure_call ::= IDENTIFIER:id procedure_call_tail:pct
{:
    RESULT = new callStmt(id, pct);
:}
| WRITE:w procedure_call_tail:pct
{:
    RESULT = new callStmt("write", pct);
:}
| READ:r procedure_call_tail:pct 
{:
    RESULT = new callStmt("read", pct);
:}
| WRITELN:wl procedure_call_tail:pct
{:
    RESULT = new callStmt("writeln", pct);
:};

procedure_call_tail ::= actual_parameters:ap
{: RESULT = ap; :}
| {: RESULT = null; :};

actual_parameters ::= LPAREN RPAREN
{:
    RESULT = new actualParameters();
:}
| LPAREN expression:e actual_parameters_tail:apt RPAREN
{:
    if (apt == null)
        RESULT = new actualParameters();
    else
        RESULT = new actualParameters(apt);
    RESULT.exprs.add(e);
:};

actual_parameters_tail ::= COMMA expression:e actual_parameters_tail:apt
{:
    if (apt == null)
        RESULT = new ArrayList<>();
    else
        RESULT = apt;
    RESULT.add(e);
:}
| {: RESULT = null; :};

assignment ::= IDENTIFIER:id selector:s ASSIGN expression:e
{:
    RESULT = new assignmentStmt(id, s, e);
:};

expression ::= simple_expression:se expr_tail:et 
{:
    if (et == null)
        RESULT = new expr(se);
    else
        RESULT = new expr(se, et.op, et.rhs);
:};

expr_tail ::= tail_op:top simple_expression:se
{:
    RESULT = new expr();
    RESULT.op = top;
    RESULT.rhs = se;
:}
| {: RESULT = null; :};

tail_op ::= EQUAL {: RESULT = "="; :}
| NOT_EQUAL {: RESULT = "#"; :}
| LESS {: RESULT = "<"; :}
| LESS_EQUAL {: RESULT = "<="; :}
| GREATER {: RESULT = ">"; :}
| GREATER_EQUAL {: RESULT = ">="; :};

simple_expression ::= head_op:hop term:t simple_expression_tail:set
{:
    if (set != null) {
        RESULT = set;
        RESULT.lhs = t;
        RESULT.signed = hop;
    }
    else
        RESULT = new simpleExpr(hop, t);

:};

head_op ::= ADD {: RESULT = "+"; :}
| MINUS {: RESULT = "-"; :}
| {: RESULT = null; :};

simple_expression_tail ::= simple_tail_op:stop term:t simple_expression_tail:set
{:
    if (set == null)
        RESULT = new simpleExpr();
    else
        RESULT = set;
    RESULT.op.add(stop);
    RESULT.rhs.add(t);
:}
| {: RESULT = null; :};

simple_tail_op ::= ADD {: RESULT = "+"; :}
| MINUS {: RESULT = "-"; :}
| OR {: RESULT = "or"; :};

term ::= factor:f term_tail:tt
{:
    if (tt != null) {
        RESULT = tt;
        RESULT.lhs = f;
    }
    else
        RESULT = new termAST(f);
:};

term_tail ::= term_tail_op:ttop factor:f term_tail:tt
{:
    if (tt == null)
        RESULT = new termAST();
    else
        RESULT = tt;
    RESULT.op.add(ttop);
    RESULT.rhs.add(f);
:}
| {: RESULT = null; :};

term_tail_op ::= MUL {: RESULT = "*"; :}
| DIV {: RESULT = "div"; :}
| MOD {: RESULT = "mod"; :}
| AND {: RESULT = "&"; :};

factor ::= IDENTIFIER:id selector:s
{:
    RESULT = new factorAST(id, s, false);
:}
| numbers:n
{:
    RESULT = new factorAST(n, false);
:}
| NOT factor:f
{:
    RESULT = f;
    RESULT.negated = true;
:}
| LPAREN expression:e RPAREN
{:
    RESULT = new factorAST(e, false);
:};

selector ::= DOT IDENTIFIER:id selector:s 
{:
    if (s == null)
        RESULT = new selectorAST();
    else
        RESULT = s;
    RESULT.types.add(0);
    RESULT.selectors.add(id);
:}
| LBRACKET expression:e RBRACKET selector:s
{:
    if (s == null)
        RESULT = new selectorAST();
    else
        RESULT = s;
    RESULT.types.add(1);
    RESULT.selectors.add(e);
:}
| {: RESULT = null; :};

numbers ::= NUMBER:num
{:
    RESULT = new numberAST(num);
:};