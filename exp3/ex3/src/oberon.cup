import java_cup.runtime.*;
import exceptions.*;
import java.util.ArrayList;
import java.util.HashMap;
import ast.*;

parser code {:
    private moduleBlock root;

    private boolean isGlobal;

    private ArrayList<varDec> globalVars;
    private ArrayList<constDec> globalConstants;
    private ArrayList<typeDec> globalTypes;
    private HashMap<String, Integer> globalVarsMap;
    private HashMap<String, Integer> globalConstantsMap;
    private HashMap<String, Integer> globalTypesMap;

    private ArrayList<varDec> localVars;
    private ArrayList<constDec> localConstants;
    private ArrayList<typeDec> localTypes;
    private HashMap<String, Integer> localVarMap;
    private HashMap<String, Integer> localConstantsMap;
    private HashMap<String, Integer> localTypesMap;

    private HashMap<String, typeAST> fpMap;

    private HashMap<String, typeAST> unsolvedTypes;
    private HashMap<String, String> unsolvedTypesPos;

    private ArrayList<String> unsolvedConstants;
    private HashMap<String, String> unsolvedConstantsPos;

    private ArrayList<callStmt> callStmts;
    public HashMap<callStmt, String> callStmtsPos;

    public moduleBlock getAST() {
        return root;
    }
:}

init with {:
    root = null;
    isGlobal = true;
    globalVars = null;
    globalConstants = null;
    globalTypes = null;
    globalVarsMap = null;
    globalConstantsMap = null;
    globalTypesMap = null;
    localTypes = null;
    localTypesMap = null;
    localConstants = null;
    localConstantsMap = null;
    localVarMap = null;
    localVars = null;
    fpMap = new HashMap<>();
    callStmts = new ArrayList<>();
    unsolvedTypes = new HashMap<>();
    unsolvedTypesPos = new HashMap<>();
    callStmtsPos = new HashMap<>();
    unsolvedConstants = new ArrayList<>();
    unsolvedConstantsPos = new HashMap<>();
:}

scan with {:
    return getScanner().next_token();
:}

/* types */
terminal INTEGER, BOOLEAN, ARRAY, RECORD;

/* builtin functions */
terminal WRITE, WRITELN, READ;

/* keywords */
terminal OF, VAR, PROCEDURE, BEGIN, END, IF, THEN, ELSE, WHILE, DO, ELSIF, CONST, MODULE, TYPE;

/* operators */
terminal ASSIGN, COMMA, DOT, COLON, SEMICOLON, LPAREN, RPAREN, LBRACKET, RBRACKET, EQUAL, NOT_EQUAL, LESS_EQUAL, LESS, GREATER_EQUAL, GREATER, ADD, MINUS, MUL, DIV, MOD;
terminal AND, OR, NOT;

/* constant */
terminal String IDENTIFIER;
terminal Integer NUMBER;

/* where to start parse */
non terminal program;

non terminal moduleBlock modules;
non terminal declarations declaration;
non terminal procedureDec procedure_declaration;
non terminal procedureHead procedure_head;
non terminal procedureBody procedure_body;
non terminal formalParameters formal_parameters;
non terminal fpSection fp_section;
non terminal typeAST type;
non terminal recordType record_type;
non terminal arrayType array_type;
non terminal fieldList field_list;
non terminal identifierList identifier_list;
non terminal stmts statement_sequence;
non terminal stmt statement;
non terminal assignmentStmt assignment;
non terminal callStmt procedure_call;
non terminal ifStmt if_statement;
non terminal whileStmt while_statement;
non terminal actualParameters actual_parameters;
non terminal expr expression;
non terminal simpleExpr simple_expression;
non terminal termAST term;
non terminal factorAST factor;
non terminal numberAST numbers;
non terminal selectorAST selector;

non terminal stmts modules_tail;
non terminal ArrayList<constDec> const_declaration;
non terminal ArrayList<varDec> var_declaration;
non terminal ArrayList<typeDec> type_declaration;
non terminal ArrayList<procedureDec> procedure_declarations;

non terminal ArrayList<constDec> const_dectail;
non terminal ArrayList<varDec> var_dectail;
non terminal ArrayList<typeDec> type_dectail;

non terminal stmts procedure_body_tail;
non terminal formalParameters procedure_head_tail;
non terminal ArrayList<fpSection> fp_section_tail;

non terminal Boolean var_if;

non terminal ArrayList<fieldList> record_tail;

non terminal ArrayList<String> identifier_list_tail;

non terminal ArrayList<stmt> statement_sequence_tail;

non terminal ifStmt elsif_part;
non terminal stmts else_part;

non terminal actualParameters procedure_call_tail;
non terminal ArrayList<expr> actual_parameters_tail;

non terminal expr expr_tail;
non terminal String tail_op;

non terminal String head_op;
non terminal simpleExpr simple_expression_tail;
non terminal String simple_tail_op;

non terminal termAST term_tail;
non terminal String term_tail_op;

precedence left LPAREN, RPAREN;
precedence right ASSIGN;
precedence left OR;
precedence left AND;
precedence right NOT;
precedence left EQUAL, NOT_EQUAL, LESS, LESS_EQUAL, GREATER, GREATER_EQUAL;
precedence left ADD, MINUS;
precedence left MUL, DIV, MOD;
precedence left IDENTIFIER, NUMBER;

start with program;

program ::= modules:m 
{:
    if (unsolvedTypes.size() > 0) {
        boolean f = false;
        String typeName = "";
        String pos = "";
        typeAST type = null;
        for (String k : unsolvedTypes.keySet()) {
            if (!f) {
                typeName = k;
                type = unsolvedTypes.get(k);
                pos = unsolvedTypesPos.get(k);
                f = true;
            }
            else {
                break;
            }
        }
        throw new SemanticException(String.format("Type: %s is not defined at %s.", typeName, pos));
    }
    root = m;
    root.convert();
:}
| error:e {:
    if (true) 
        throw new SyntacticException();
:}
;

modules ::= MODULE IDENTIFIER:id SEMICOLON declaration:d modules_tail:s END IDENTIFIER:id1 DOT
{:
    id = id.toUpperCase();
    id1 = id1.toUpperCase();
    if (!id.equals(id1))
        throw new SemanticException("module name mismatch");
    RESULT = new moduleBlock(id, d, s);
:}
;

modules_tail ::= BEGIN statement_sequence:s 
{: RESULT = s; :}
| {: RESULT = new stmts(); :};

declaration ::= const_declaration:c type_declaration:t var_declaration:v procedure_declarations:p
{:
    RESULT = new declarations(c, t, v, p);
:};

const_declaration ::= CONST const_dectail:ct
{: 
    if (isGlobal) {
        if (ct != null) {
            globalConstants = new ArrayList<>(ct);
            globalConstantsMap = new HashMap<>();

            for (int i = 0; i < globalConstants.size(); ++i) {
                globalConstantsMap.put(globalConstants.get(i).name, i);
            }
        }
        else {
            globalConstants = new ArrayList<>();
            globalConstantsMap = new HashMap<>();
        }
    }
    else {
        if (ct != null) {
            localConstants = new ArrayList<>(ct);
            localConstantsMap = new HashMap<>();

            for (int i = 0; i < localConstants.size(); ++i) {
                localConstantsMap.put(localConstants.get(i).name, i);
            }
        }
        else {
            localConstants = new ArrayList<>();
            localConstantsMap = new HashMap<>();
        }
    }

    for (int i = 0; i < unsolvedConstants.size(); ++i) {
        String name = unsolvedConstants.get(i);
        String position = unsolvedConstantsPos.get(name);

        if (isGlobal) {
            if (globalConstantsMap.containsKey(name)) {
                unsolvedConstants.remove(i);
                unsolvedConstantsPos.remove(name);
            }
            else {
                throw new SemanticException(String.format("Constant: %s is not defined at %s.", name, position));
            }
        }
        else {
            if (localConstantsMap.containsKey(name)) {
                unsolvedConstants.remove(i);
                unsolvedConstantsPos.remove(name);
            }
            else if (globalConstantsMap.containsKey(name)) {
                unsolvedConstants.remove(i);
                unsolvedConstantsPos.remove(name);
            }
            else {
                throw new SemanticException(String.format("Constant: %s is not defined at %s.", name, position));
            }
        }
    }

    RESULT = ct; 
:}
| {: 
    if (isGlobal) {
        globalConstants = new ArrayList<>();
        globalConstantsMap = new HashMap<>();
    }
    else {
        localConstants = new ArrayList<>();
        localConstantsMap = new HashMap<>();
    }
    RESULT = new ArrayList<constDec>(); 
:};
const_dectail ::= IDENTIFIER:id EQUAL expression:e SEMICOLON const_dectail:ct
{:
    if (!e.isConstant) {
        throw new SemanticException(String.format("Constant Exception: %s is not a constant expression.", e));
    }
    id = id.toUpperCase();
    if (ct == null)
        RESULT = new ArrayList<>();
    else
        RESULT = ct;
    constDec tmp = new constDec(id, e);
    tmp.value.isConstant = true;
    RESULT.add(tmp);
:}
| IDENTIFIER:id expression:e SEMICOLON const_dectail:ct
{:
    if (true)
        throw new MissingOperatorException("Missing '=' for const declaration.");
:}
| {: RESULT = new ArrayList<constDec>(); :};

type_declaration ::= TYPE type_dectail:tt
{:
    if (isGlobal) {
        if (tt != null) {
            globalTypes = new ArrayList<>(tt);
            globalTypesMap = new HashMap<>();

            for (int i = 0; i < globalTypes.size(); ++i) {
                globalTypesMap.put(globalTypes.get(i).name, i);
            }
        }

        else {
            globalTypes = new ArrayList<>();
            globalTypesMap = new HashMap<>();
        }
    }
    else {
        if (tt != null) {
            localTypes = new ArrayList<>(tt);
            localTypesMap = new HashMap<>();

            for (int i = 0; i < localTypes.size(); ++i) {
                localTypesMap.put(localTypes.get(i).name, i);
            }
        }
        else {
            localTypes = new ArrayList<>();
            localTypesMap = new HashMap<>();
        }
    }

    RESULT = tt;

    for (String typeName : unsolvedTypes.keySet()) {
        Integer idx = null;
        if (localTypes != null) {
            idx = localTypesMap.get(typeName);
            if (idx == null) {
                idx = globalTypesMap.get(typeName);
                if (idx == null) {
                    throw new SemanticException("Type " + typeName + " is not defined.");
                }
                else {
                    // found at global
                    typeDec td = globalTypes.get(idx);
                    unsolvedTypes.get(typeName).name = td.type.name;
                    unsolvedTypes.get(typeName).type = td.type.type;
                    unsolvedTypes.remove(typeName);
                    unsolvedTypesPos.remove(typeName);
                }
            }
            else {
                // found at local
                typeDec td = localTypes.get(idx);
                unsolvedTypes.get(typeName).name = td.type.name;
                unsolvedTypes.get(typeName).type = td.type.type;
                unsolvedTypes.remove(typeName);
                unsolvedTypesPos.remove(typeName);
            }
        }
        else {
            idx = globalTypesMap.get(typeName);
            if (idx == null) {
                throw new SemanticException("Type " + typeName + " is not defined.");
            }
            else {
                // found at global
                typeDec td = globalTypes.get(idx);
                unsolvedTypes.get(typeName).name = td.type.name;
                unsolvedTypes.get(typeName).type = td.type.type;
                unsolvedTypes.remove(typeName);
                unsolvedTypesPos.remove(typeName);
            }
        }
    }
:}
| {:
    if (isGlobal) {
        globalTypes = new ArrayList<>();
        globalTypesMap = new HashMap<>();
    }
    else {
        localTypes = new ArrayList<>();
        localTypesMap = new HashMap<>();
    }

    RESULT = new ArrayList<typeDec>(); 
:};
type_dectail ::= IDENTIFIER:id EQUAL type:t SEMICOLON type_dectail:tt
{:
    if (tt == null)
        RESULT = new ArrayList<>();
    else
        RESULT = tt;
    RESULT.add(new typeDec(id.toUpperCase(), t));
:}
| IDENTIFIER:id type:t SEMICOLON type_dectail:tt
{:
    if (true)
        throw new MissingOperatorException("Missing '=' for type declaration.");
:} 
| {: RESULT = new ArrayList<typeDec>(); :};

var_declaration ::= VAR var_dectail:vt
{: 
    if (isGlobal) {
        if (vt != null) {
            globalVars = new ArrayList<>(vt);
            globalVarsMap = new HashMap<>();
            for (int i = 0; i < globalVars.size(); ++i) {
                for (String ident : globalVars.get(i).idList.identifiers) {
                    globalVarsMap.put(ident, i);
                }
            }
        }
        else {
            globalVars = new ArrayList<>();
            globalVarsMap = new HashMap<>();
        }
    }
    else {
        if (vt != null) {
            localVars = new ArrayList<>(vt);
            localVarMap = new HashMap<>();
            for (int i = 0; i < localVars.size(); ++i) {
                for (String ident : localVars.get(i).idList.identifiers) {
                    localVarMap.put(ident, i);
                }
            }
        }
        else {
            localVars = new ArrayList<>();
            localVarMap = new HashMap<>();
        }
    }
    RESULT = vt; 
:}
| {:
    if (isGlobal) {
        globalVars = new ArrayList<>();
        globalVarsMap = new HashMap<>();
    }
    else {
        localVars = new ArrayList<>();
        localVarMap = new HashMap<>();
    }
    RESULT = new ArrayList<varDec>(); 
:};

var_dectail ::= identifier_list:il COLON type:t SEMICOLON var_dectail:vt
{:
    if (vt == null)
        RESULT = new ArrayList<>();
    else
        RESULT = vt;
    RESULT.add(new varDec(il, t));
:}
| identifier_list:il COLON SEMICOLON var_dectail
{:
    if(true)
        throw new SyntacticException("Type Missed for variable declaration.");
:}
| {: RESULT = new ArrayList<varDec>();; :};

procedure_declarations ::= procedure_declaration:p SEMICOLON procedure_declarations:pd
{:
    if (pd == null)
        RESULT = new ArrayList<>();
    else
        RESULT = pd;
    RESULT.add(p);
:}
| {: RESULT = new ArrayList<procedureDec>(); :};

procedure_declaration ::= procedure_head:h SEMICOLON procedure_body:b
{:
    if (!h.name.equals(b.name))
        throw new SemanticException("procedure name mismatch");
    RESULT = new procedureDec(h, b);
    RESULT.body.calls = callStmts;
    RESULT.body.callsPos = callStmtsPos;
    callStmts = new ArrayList<>();
    callStmtsPos = new HashMap<>();
:};

procedure_body ::= declaration:d procedure_body_tail:pbd END IDENTIFIER:id
{:
    RESULT = new procedureBody(d, pbd, id.toUpperCase());
:};

procedure_body_tail ::= BEGIN statement_sequence:s 
{: RESULT = s; :}
| {: RESULT = new stmts(); :};

procedure_head ::= PROCEDURE IDENTIFIER:id procedure_head_tail:fp
{:
    if (isGlobal)
        isGlobal = false;
    RESULT = new procedureHead(id.toUpperCase(), fp);
:};

procedure_head_tail ::= formal_parameters:fp
{:
    fpMap = new HashMap<>();

    for (fpSection f : fp.fpList) {
        identifierList list = f.identifierList;
        typeAST type = f.type;
        for (String s : list.identifiers) {
            fpMap.put(s, type);
        }
    }

    RESULT = fp; 
:}
| {: RESULT = new formalParameters(); :};

formal_parameters ::= LPAREN fp_section:fp fp_section_tail:fpt RPAREN
{:
    if (fpt == null)
        RESULT = new formalParameters();
    else
        RESULT = new formalParameters(fpt);
    RESULT.fpList.add(fp);
:}
| LPAREN RPAREN
{:
    RESULT = new formalParameters();
:}
| LPAREN error {:
    if (true) 
        throw new MissingRightParenthesisException();
:}
| error RPAREN {:
    if (true)
        throw new MissingLeftParenthesisException();
:}
;

fp_section_tail ::= SEMICOLON fp_section:fp fp_section_tail:fpt
{:
    if (fpt == null)
        RESULT = new ArrayList<>();
    else
        RESULT = fpt;
    RESULT.add(fp);
:}
| {: RESULT = null; :};

fp_section ::= var_if:isvar identifier_list:il COLON type:t
{:
    RESULT = new fpSection(isvar, il, t);
:}
| var_if identifier_list COLON
{:
    if(true)
        throw new SyntacticException("Type Missed for formal parameters.");
:}
;

var_if ::= VAR {: RESULT = true; :}
| {: RESULT = false; :};

type ::= IDENTIFIER:id 
{:
    id = id.toUpperCase();
    // try to find out the type
    Integer idx = globalTypesMap.get(id);
    typeAST type = null;
    if (idx == null) {
        idx = localTypesMap.get(id);
        if (idx == null) {
            unsolvedTypes.put(id, new typeAST());
            unsolvedTypesPos.put(id, String.format("<%d:%d>", ((OberonScanner) getScanner()).getLine(), ((OberonScanner) getScanner()).getCol()));
            // throw new SemanticException("Type " + id + " not found.");
        }
        else
            type = localTypes.get(idx).type;
    }
    else {
        type = globalTypes.get(idx).type;
    }
    if (idx == null) {
        RESULT = unsolvedTypes.get(id);
    }
    else {
        RESULT = new typeAST();
        RESULT.name = type.name;
        RESULT.type = type.type;
    }
:}
| INTEGER {: RESULT = new typeAST("INTEGER"); :}
| BOOLEAN {: RESULT = new typeAST("BOOLEAN"); :}
| array_type:a
{:
    RESULT = new typeAST("ARRAY", a);
:}
| record_type:r
{:
    RESULT = new typeAST("RECORD", r);
:};

record_type ::= RECORD field_list:f record_tail:rt END
{:
    if (rt == null)
        RESULT = new recordType();
    else
        RESULT = new recordType(rt);
    RESULT.fieldLists.add(f);
:};

record_tail ::= SEMICOLON field_list:f record_tail:rt
{:
    if (rt == null)
        RESULT = new ArrayList<>();
    else
        RESULT = rt;
    if (f != null)
        RESULT.add(f);
:}
| {: RESULT = null; :};

field_list ::= identifier_list:il COLON type:t
{:
    RESULT = new fieldList(il, t);
:}
| identifier_list COLON 
{:
    if (true)
        throw new SyntacticException("Type Missed in field list.");
:}
| {: RESULT = null; :};

array_type ::= ARRAY expression:e OF type:t
{:
    RESULT = new arrayType(e, t);
:}
| ARRAY OF type
{:
    if (true)
        throw new SyntacticException("Undefined Array Length.");
:};

identifier_list ::= IDENTIFIER:id identifier_list_tail:ilt
{:
    if (ilt == null)
        RESULT = new identifierList();
    else
        RESULT = new identifierList(ilt);
    RESULT.identifiers.add(id.toUpperCase());
:};

identifier_list_tail ::= COMMA IDENTIFIER:id identifier_list_tail:ilt
{:
    if (ilt == null)
        RESULT = new ArrayList<>();
    else
        RESULT = ilt;
    RESULT.add(id.toUpperCase());
:}
| {: RESULT = null; :};

statement_sequence ::= statement:s statement_sequence_tail:sst
{:
    if (sst == null)
        RESULT = new stmts();
    else
        RESULT = new stmts(sst);
    RESULT.statements.add(s);
:}
;

statement_sequence_tail ::= SEMICOLON statement:s statement_sequence_tail:sst
{:
    if (sst == null)
        RESULT = new ArrayList<>();
    else
        RESULT = sst;
    RESULT.add(s);
:}
| {: RESULT = null; :};

statement ::= assignment:a {: RESULT = new stmt(a); :}
| procedure_call:p {: RESULT = new stmt(p); :}
| if_statement:i {: RESULT = new stmt(i); :}
| while_statement:w {: RESULT = new stmt(w); :};

while_statement ::= WHILE expression:e DO statement_sequence:ss END
{:
    RESULT = new whileStmt(e, ss);
:};

if_statement ::= IF expression:e THEN statement_sequence:ss elsif_part:el else_part:endp END
{:
    if (el != null && endp != null)
        RESULT = new ifStmt(e, ss, el.elseIfs, endp);
    else if (el != null) {
        RESULT = new ifStmt(e, ss);
        RESULT.elseIfs = el.elseIfs;
    }
    else if (endp != null) {
        RESULT = new ifStmt(e, ss);
        RESULT.elseBody = endp;
    }
    else {
        RESULT = new ifStmt(e, ss);
    }
:};

elsif_part ::= ELSIF expression:e THEN statement_sequence:ss elsif_part:el
{:
    if (el == null) 
        RESULT = new ifStmt();
    else
        RESULT = el;
    RESULT.elseIfs.add(new ifStmt(e, ss, true));
    RESULT.isElseIf = true;
:}
| {: RESULT = null; :};

else_part ::= ELSE statement_sequence:ss
{:
    RESULT = ss;
:}
| {: RESULT = null; :};

procedure_call ::= IDENTIFIER:id procedure_call_tail:pct
{:  
    RESULT = new callStmt(id.toUpperCase(), pct);
    callStmts.add(RESULT);
    callStmtsPos.put(RESULT, String.format("<%d:%d>", ((OberonScanner)getScanner()).getLine(), ((OberonScanner)getScanner()).getCol()));
:}
| WRITE:w procedure_call_tail:pct
{:
    if (pct.exprs.size() != 1) {
        throw new ParameterMismatchedException(String.format("WRITE accepts 1 params, but get %d.", pct.exprs.size()));
    }
    RESULT = new callStmt("WRITE", pct);
:}
| READ:r procedure_call_tail:pct 
{:
    if (pct.exprs.size() != 1) {
        throw new ParameterMismatchedException(String.format("READ accepts 1 params, but get %d.", pct.exprs.size()));
    }
    RESULT = new callStmt("READ", pct);
    
:}
| WRITELN:wl procedure_call_tail:pct
{:
    if (pct.exprs.size() != 0) {
        throw new ParameterMismatchedException(String.format("WRITELN accepts 0 params, but get %d.", pct.exprs.size()));
    }
    RESULT = new callStmt("WRITELN", pct);
:};

procedure_call_tail ::= actual_parameters:ap
{: RESULT = ap; :};

actual_parameters ::= LPAREN RPAREN
{:
    RESULT = new actualParameters();
:}
| LPAREN expression:e actual_parameters_tail:apt RPAREN
{:
    if (apt == null)
        RESULT = new actualParameters();
    else
        RESULT = new actualParameters(apt);
    RESULT.exprs.add(e);
:}
| {: RESULT = new actualParameters(); :}
| LPAREN expression:e actual_parameters_tail:apt {: if(true) throw new MissingRightParenthesisException(); :}
| expression:e actual_parameters_tail:apt RPAREN {: if (true) throw new MissingLeftParenthesisException(); :};

actual_parameters_tail ::= COMMA expression:e actual_parameters_tail:apt
{:
    if (apt == null)
        RESULT = new ArrayList<>();
    else
        RESULT = apt;
    RESULT.add(e);
:}
| {: RESULT = null; :};

assignment ::= IDENTIFIER:id selector:s ASSIGN expression:e
{:
    id = id.toUpperCase();
    // local vars
    Integer idx = localVarMap.get(id);
    typeAST type = null;
    if (idx == null) {
        // try parameters
        type = fpMap.get(id);
        if (type == null) {
            // try to global vars
            idx = globalVarsMap.get(id);
            if (idx == null) {
                // try local const
                // but it is not allowed to assign to const
                // so just to throw exceptions
                idx = localConstantsMap.get(id);
                if (idx == null) {
                    // try global const
                    idx = globalConstantsMap.get(id);
                    if (idx == null) {
                        // can not found
                        throw new SemanticException(String.format("%s is not defined.", id));
                    }
                    throw new SemanticException(String.format("%s is a global constant, can not be assigned.", id));
                }
                else {
                    // local const
                    throw new SemanticException(String.format("%s is a local constant, can not be assigned.", id));
                }
            }
            else {
                // global vars
                type = globalVars.get(idx).type;
            }
        }
    }
    else {
        // local vars
        type = localVars.get(idx).type;
    }

    // type checking
    if (type.name.equals("INTEGER")) {
        if (s != null) {
            throw new TypeMismatchedException("INTEGER does not support selector.");
        }
        if (!e.getType().name.equals("INTEGER")) {
            throw new TypeMismatchedException("INTEGER can only be assigned with INTEGER.");
        }
    }
    else if (type.name.equals("BOOLEAN")) {
        if (s != null) {
            throw new TypeMismatchedException("BOOLEAN does not support selector.");
        }
        if (!e.getType().name.equals("BOOLEAN")) {
            throw new TypeMismatchedException("BOOLEAN can only be assigned with BOOLEAN.");
        }

    }
    else if (type.name.equals("ARRAY")) {
        if (s == null) {
            throw new TypeMismatchedException("ARRAY must have selector.");
        }

        arrayType artype = (arrayType)type.type;
        recordType rectype = null;
        typeAST tmp = null;
        typeAST finalType = null;

        for (int i = s.types.size() - 1; i >= 0; --i) {
            // selector is array
            if (s.types.get(i) == 1) {
                if (artype == null) {
                    throw new TypeMismatchedException("ARRAY selector do not match.");
                }
                tmp = artype.type;

                if (tmp.type == null) {
                    finalType = tmp;
                    rectype = null;
                    tmp = null;
                    artype = null;
                }
                else {
                    if (tmp.type instanceof arrayType) {
                        artype = (arrayType) tmp.type;
                        rectype = null;
                        tmp = null;
                    }
                    else if (tmp.type instanceof recordType) {
                        artype = null;
                        rectype = (recordType) tmp.type;
                        tmp = null;
                    }
                }
            }
            // record selector
            else if (s.types.get(i) == 0) {
                if (rectype == null) {
                    throw new TypeMismatchedException("RECORD selector do not match.");
                }

                typeAST tmpType = null;
                for (fieldList fl : rectype.fieldLists) {
                    tmpType = fl.type;
                    for (String name : fl.ids.identifiers) {
                        if (name.equals(((String) s.selectors.get(i)))) {
                            tmp = tmpType;
                            break;
                        }
                    }
                }

                if (tmp == null) {
                    // can not find the field
                    throw new TypeMismatchedException(String.format("%s can not be found in RECORD.", s.selectors.get(i)));
                }

                if (tmp.type == null) {
                    finalType = tmp;
                    rectype = null;
                    tmp = null;
                    artype = null;
                }
                else {
                    if (tmp.type instanceof arrayType) {
                        artype = (arrayType) tmp.type;
                        rectype = null;
                        tmp = null;
                    }
                    else if (tmp.type instanceof recordType) {
                        artype = null;
                        rectype = (recordType) tmp.type;
                        tmp = null;
                    }
                }
            }
        }

        if (finalType == null) {
            throw new TypeMismatchedException("ARRAY/RECORD selector do not match.");
        }

        if (!finalType.name.equals(e.getType().name)) {
            throw new TypeMismatchedException(String.format("%s can only be assigned with %s.", finalType.name, e.getType().name));
        }
    }
    else if (type.name.equals("RECORD")) {
        if (s == null) {
            throw new TypeMismatchedException("ARRAY must have selector.");
        }

        arrayType artype = null;
        recordType rectype = (recordType)type.type;
        typeAST tmp = null;
        typeAST finalType = null;

        for (int i = s.types.size() - 1; i >= 0; --i) {
            // selector is array
            if (s.types.get(i) == 1) {
                if (artype == null) {
                    throw new TypeMismatchedException("ARRAY selector do not match.");
                }
                tmp = artype.type;

                if (tmp.type == null) {
                    finalType = tmp;
                    rectype = null;
                    tmp = null;
                    artype = null;
                }
                else {
                    if (tmp.type instanceof arrayType) {
                        artype = (arrayType) tmp.type;
                        rectype = null;
                        tmp = null;
                    }
                    else if (tmp.type instanceof recordType) {
                        artype = null;
                        rectype = (recordType) tmp.type;
                        tmp = null;
                    }
                }
            }
            // record selector
            else if (s.types.get(i) == 0) {
                if (rectype == null) {
                    throw new TypeMismatchedException("RECORD selector do not match.");
                }

                typeAST tmpType = null;
                for (fieldList fl : rectype.fieldLists) {
                    tmpType = fl.type;
                    for (String name : fl.ids.identifiers) {
                        if (name.equals(((String) s.selectors.get(i)))) {
                            tmp = tmpType;
                            break;
                        }
                    }
                }

                if (tmp == null) {
                    // can not find the field
                    throw new TypeMismatchedException(String.format("%s can not be found in RECORD.", s.selectors.get(i)));
                }

                if (tmp.type == null) {
                    finalType = tmp;
                    rectype = null;
                    tmp = null;
                    artype = null;
                }
                else {
                    if (tmp.type instanceof arrayType) {
                        artype = (arrayType) tmp.type;
                        rectype = null;
                        tmp = null;
                    }
                    else if (tmp.type instanceof recordType) {
                        artype = null;
                        rectype = (recordType) tmp.type;
                        tmp = null;
                    }
                }
            }
        }

        if (finalType == null) {
            throw new TypeMismatchedException("ARRAY/RECORD selector do not match.");
        }

        if (!finalType.name.equals(e.getType().name)) {
            throw new TypeMismatchedException(String.format("%s can only be assigned with %s.", finalType.name, e.getType().name));
        }
    }
    else {
        throw new SemanticException(String.format("Type %s is not supported.", type.name));
    }

    RESULT = new assignmentStmt(id, s, e);
:};

expression ::= simple_expression:se expr_tail:et
{:
    if (et == null)
        RESULT = new expr(se);
    else
        RESULT = new expr(se, et.op, et.rhs);
:}
| error {:
    if (true)
        throw new MissingLeftParenthesisException();
:};

expr_tail ::= tail_op:top simple_expression:se
{:
    if (se.getType().name.equals("BOOLEAN"))
        throw new TypeMismatchedException();
    RESULT = new expr();
    RESULT.op = top;
    RESULT.rhs = se;
:}
| tail_op:top 
{:
    if(true)
        throw new MissingOperandException();
:}
| simple_expression 
{:
    if (true)
        throw new MissingOperatorException();
:}
| {: RESULT = null; :};

tail_op ::= EQUAL {: RESULT = "="; :}
| NOT_EQUAL {: RESULT = "#"; :}
| LESS {: RESULT = "<"; :}
| LESS_EQUAL {: RESULT = "<="; :}
| GREATER {: RESULT = ">"; :}
| GREATER_EQUAL {: RESULT = ">="; :};

simple_expression ::= head_op:hop term:t simple_expression_tail:set
{:
    if (hop != null) {
        // must be arithmetic
        if (t.getType().name.equals("BOOLEAN"))
            throw new TypeMismatchedException();
    }
    if (set != null) {
        RESULT = set;
        RESULT.lhs = t;
        RESULT.signed = hop;
    }
    else
        RESULT = new simpleExpr(hop, t);
:};

head_op ::= ADD {: RESULT = "+"; :}
| MINUS {: RESULT = "-"; :}
| {: RESULT = null; :};

simple_expression_tail ::= simple_tail_op:stop term:t simple_expression_tail:set
{:
    if (stop.equals("or")) {
        // boolean
        if (t.getType().name.equals("INTEGER"))
            throw new TypeMismatchedException();
    }
    else {
        // arithmetic
        if (t.getType().name.equals("BOOLEAN"))
            throw new TypeMismatchedException();
    }
    if (set == null)
        RESULT = new simpleExpr();
    else
        RESULT = set;
    RESULT.op.add(stop);
    RESULT.rhs.add(t);
:}
| simple_tail_op:stop
{:
    if(true)
        throw new MissingOperandException();
:}
| term:t
{:
    if (true)
        throw new MissingOperatorException();
:}
| {: RESULT = null; :};

simple_tail_op ::= ADD {: RESULT = "+"; :}
| MINUS {: RESULT = "-"; :}
| OR {: RESULT = "OR"; :};

term ::= factor:f term_tail:tt
{:
    if (tt != null) {
        RESULT = tt;
        RESULT.lhs = f;
    }
    else
        RESULT = new termAST(f);
:};

term_tail ::= term_tail_op:ttop factor:f term_tail:tt
{:
    if (ttop == "&") {
        // logical
        typeAST type = f.getType();
        if (type.name.equals("INTEGER")) {
            throw new TypeMismatchedException();
        }
    }
    else {
        // arithmetic
        if (f.getType().name.equals("BOOLEAN"))
            throw new TypeMismatchedException();
    }
    if (tt == null)
        RESULT = new termAST();
    else
        RESULT = tt;
    RESULT.op.add(ttop);
    RESULT.rhs.add(f);
:}
| factor {:
    if (true)
        throw new MissingOperatorException();
:}
| term_tail_op {:
    if (true)
        throw new MissingOperandException();
:}
| {: RESULT = null; :};

term_tail_op ::= MUL {: RESULT = "*"; :}
| DIV {: RESULT = "DIV"; :}
| MOD {: RESULT = "MOD"; :}
| AND {: RESULT = "&"; :};

factor ::= IDENTIFIER:id selector:select
{:
    boolean undefined = false;
    id = id.toUpperCase();
    varDec var = null;
    constDec constant = null;
    // local var
    Integer idx = localVarMap.get(id);
    typeAST type = null;
    if (idx == null) {
        // try parameters
        type = fpMap.get(id);
        if (type == null) {
            // try to global vars
            idx = globalVarsMap.get(id);
            if (idx == null) {
                // try local const
                idx = localConstantsMap.get(id);
                if (idx == null) {
                    // try global const
                    idx = globalConstantsMap.get(id);
                    if (idx == null) {
                        // can not found
                        // may be is in the constant declaration?
                        unsolvedConstants.add(id);
                        unsolvedConstantsPos.put(id, String.format("<%d:%d>", ((OberonScanner) getScanner()).getLine(), ((OberonScanner) getScanner()).getCol()));
                        undefined = true;
                        // constant = new constDec();
                        // throw new SemanticException(String.format("%s is not defined.", id));
                    }
                    else {
                        // global constant
                        constant = globalConstants.get(idx);
                        if (constant.type == 0) {
                            type = new typeAST("INTEGER");
                        }
                        else {
                            type = new typeAST("BOOLEAN");
                        }
                    }
                }
                else {
                    // local constant
                    constant = localConstants.get(idx);
                    if (constant.type == 0) {
                        type = new typeAST("INTEGER");
                    }
                    else {
                        type = new typeAST("BOOLEAN");
                    }
                }
            }
            else {
                // global vars
                var = globalVars.get(idx);
                type = var.type;
            }
        }
        else {
            // parameters
            // we have assigned the type, so do nothing here
        }
    }
    else {
        // local vars
        var = localVars.get(idx);
        type = var.type;
    }

    RESULT = new factorAST(id, select, false);

    if (undefined) 
        RESULT.isConstant = true;

    if (!undefined) {
        if (constant != null)
            RESULT.isConstant = true;

        if (type.name.equals("INTEGER")) {
            if (select != null) {
                throw new TypeMismatchedException("INTEGER does not support selector.");
            }
            RESULT.typeGenerate = new typeAST("INTEGER");
        } 
        else if (type.name.equals("BOOLEAN")) {
            if (select != null) {
                throw new TypeMismatchedException("BOOLEAN does not support selector.");
            }
            RESULT.typeGenerate = new typeAST("BOOLEAN");
        }
        else if (type.name.equals("ARRAY")) {
            if (select == null) {
                throw new TypeMismatchedException("ARRAY must have selector.");
            }

            arrayType artype = (arrayType)type.type;
            recordType rectype = null;
            typeAST tmp = null;
            typeAST finalType = null;

            for (int i = select.types.size() - 1; i >= 0; --i) {
                // selector is array
                if (select.types.get(i) == 1) {
                    if (artype == null) {
                        throw new TypeMismatchedException("ARRAY selector do not match.");
                    }
                    tmp = artype.type;

                    if (tmp.type == null) {
                        finalType = tmp;
                        rectype = null;
                        tmp = null;
                        artype = null;
                    }
                    else {
                        if (tmp.type instanceof arrayType) {
                            artype = (arrayType) tmp.type;
                            rectype = null;
                            tmp = null;
                        }
                        else if (tmp.type instanceof recordType) {
                            artype = null;
                            rectype = (recordType) tmp.type;
                            tmp = null;
                        }
                    }
                }
                // record selector
                else if (select.types.get(i) == 0) {
                    if (rectype == null) {
                        throw new TypeMismatchedException("RECORD selector do not match.");
                    }

                    typeAST tmpType = null;
                    for (fieldList fl : rectype.fieldLists) {
                        tmpType = fl.type;
                        for (String name : fl.ids.identifiers) {
                            if (name.equals(((String) select.selectors.get(i)))) {
                                tmp = tmpType;
                                break;
                            }
                        }
                    }

                    if (tmp == null) {
                        // can not find the field
                        throw new TypeMismatchedException(String.format("%s can not be found in RECORD.", select.selectors.get(i)));
                    }

                    if (tmp.type == null) {
                        finalType = tmp;
                        rectype = null;
                        tmp = null;
                        artype = null;
                    }
                    else {
                        if (tmp.type instanceof arrayType) {
                            artype = (arrayType) tmp.type;
                            rectype = null;
                            tmp = null;
                        }
                        else if (tmp.type instanceof recordType) {
                            artype = null;
                            rectype = (recordType) tmp.type;
                            tmp = null;
                        }
                    }
                }
            }

            if (finalType == null) {
                throw new TypeMismatchedException("ARRAY/RECORD selector do not match.");
            }

            RESULT.typeGenerate = new typeAST(finalType.name, finalType.type);
        }
        else if (type.name.equals("RECORD")) {
            if (select == null) {
                throw new TypeMismatchedException("ARRAY must have selector.");
            }

            arrayType artype = null;
            recordType rectype = (recordType)type.type;
            typeAST tmp = null;
            typeAST finalType = null;

            for (int i = select.types.size() - 1; i >= 0; --i) {
                // selector is array
                if (select.types.get(i) == 1) {
                    if (artype == null) {
                        throw new TypeMismatchedException("ARRAY selector do not match.");
                    }
                    tmp = artype.type;

                    if (tmp.type == null) {
                        finalType = tmp;
                        rectype = null;
                        tmp = null;
                        artype = null;
                    }
                    else {
                        if (tmp.type instanceof arrayType) {
                            artype = (arrayType) tmp.type;
                            rectype = null;
                            tmp = null;
                        }
                        else if (tmp.type instanceof recordType) {
                            artype = null;
                            rectype = (recordType) tmp.type;
                            tmp = null;
                        }
                    }
                }
                // record selector
                else if (select.types.get(i) == 0) {
                    if (rectype == null) {
                        throw new TypeMismatchedException("RECORD selector do not match.");
                    }

                    typeAST tmpType = null;
                    for (fieldList fl : rectype.fieldLists) {
                        tmpType = fl.type;
                        for (String name : fl.ids.identifiers) {
                            if (name.equals(((String) select.selectors.get(i)))) {
                                tmp = tmpType;
                                break;
                            }
                        }
                    }

                    if (tmp == null) {
                        // can not find the field
                        throw new TypeMismatchedException(String.format("%s can not be found in RECORD.", select.selectors.get(i)));
                    }

                    if (tmp.type == null) {
                        finalType = tmp;
                        rectype = null;
                        tmp = null;
                        artype = null;
                    }
                    else {
                        if (tmp.type instanceof arrayType) {
                            artype = (arrayType) tmp.type;
                            rectype = null;
                            tmp = null;
                        }
                        else if (tmp.type instanceof recordType) {
                            artype = null;
                            rectype = (recordType) tmp.type;
                            tmp = null;
                        }
                    }
                }
            }

            if (finalType == null) {
                throw new TypeMismatchedException("ARRAY/RECORD selector do not match.");
            }

            RESULT.typeGenerate = new typeAST(finalType.name, finalType.type);
        }
        else {
            throw new SyntacticException("Unknown type: " + type.name);
        }
    }
:}
| numbers:n
{:
    RESULT = new factorAST(n, false);
    RESULT.isConstant = true;
:}
| NOT factor:f
{:
    typeAST type = f.getType();
    if (type.name.equals("INTEGER")) {
        throw new TypeMismatchedException();
    }
    RESULT = f;
    RESULT.negated = true;
:}
| LPAREN expression:e RPAREN
{:
    RESULT = new factorAST(e, false);
:}
| LPAREN expression error {:
    if (true)
        throw new MissingRightParenthesisException();
:}
;

selector ::= DOT IDENTIFIER:id selector:s 
{:
    if (s == null)
        RESULT = new selectorAST();
    else
        RESULT = s;
    RESULT.types.add(0);
    RESULT.selectors.add(id.toUpperCase());
:}
| LBRACKET expression:e RBRACKET selector:s
{:
    if (s == null)
        RESULT = new selectorAST();
    else
        RESULT = s;
    RESULT.types.add(1);
    RESULT.selectors.add(e);
:}
| {: RESULT = null; :};

numbers ::= NUMBER:num
{:
    RESULT = new numberAST(num);
:};